// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function gap(gapspace, start, stop) {
  var is_prime = function (n) {
    var n$1 = Pervasives.abs(n);
    if (n$1 !== 1) {
      var _d = 2;
      while(true) {
        var d = _d;
        if (Caml_int32.imul(d, d) > n$1) {
          return true;
        } else if (Caml_int32.mod_(n$1, d) !== 0) {
          _d = d + 1 | 0;
          continue ;
        } else {
          return false;
        }
      };
    } else {
      return false;
    }
  };
  var are_both_prime = function (start, stop) {
    if (is_prime(start)) {
      return is_prime(stop);
    } else {
      return false;
    }
  };
  var $neg$neg = function (i, j) {
    var _n = j;
    var _acc = /* [] */0;
    while(true) {
      var acc = _acc;
      var n = _n;
      if (n < i) {
        return acc;
      } else {
        _acc = /* :: */[
          n,
          acc
        ];
        _n = n - 1 | 0;
        continue ;
      }
    };
  };
  var _start = start;
  var _interstop = start + gapspace | 0;
  while(true) {
    var interstop = _interstop;
    var start$1 = _start;
    if (interstop > stop) {
      return undefined;
    } else {
      var tmp = false;
      if (are_both_prime(start$1, interstop)) {
        var list = $neg$neg(start$1 + 1 | 0, interstop - 1 | 0);
        tmp = !List.exists(is_prime, list);
      }
      if (tmp) {
        return /* tuple */[
                start$1,
                interstop
              ];
      } else {
        _interstop = (start$1 + 1 | 0) + gapspace | 0;
        _start = start$1 + 1 | 0;
        continue ;
      }
    }
  };
}

exports.gap = gap;
/* No side effect */
